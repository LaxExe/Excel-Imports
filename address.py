import openpyxl
import json


def is_1_column_tag(filepath):

    with open(filepath, "r") as f:
        info_json = json.load(f)

    is_1_column = info_json["required_fields"]["address_takes_up_1_column"]

    return is_1_column

def result_format(result, required_format, skip):
    if skip:
        return True
    
    formatted_parts = []

    for key in required_format:
        if key in result:
            formatted_parts.append(result[key])
        else:
            return True

    formatted_string = ", ".join(formatted_parts)
    return formatted_string

def column_1_address_skip(address, format_str, separator):
    format_parts = [f.strip() for f in format_str.split(separator)]
    address_parts = [a.strip() for a in address.split(separator)]

    required_format = [ "Postal Code", "Street", "City", "Province"]

    result = {}
    skip = False

    extra_count = len(address_parts) - len(format_parts)

    if extra_count >= 0:
        for i, key in enumerate(format_parts):
            if i == 0:
                value = separator.join(address_parts[:extra_count + 1]).strip()
            else:
                value = address_parts[i + extra_count]

            if len(value) < 2 or len(value) > 40:
                skip = True  
                break

            result[key] = value
    else:
        skip = True

    if skip:
        return skip

    result_string = result_format(result, required_format, skip)

    return result_string


def column_multi_address(row, row_number, json_path="info.json"):
    """
    Handles multi-column address rows.

    - If a column doesn't exist in JSON, it's skipped.
    - If a column exists but the value in a row is missing or invalid, the field is marked for AI.
    - A formatted address is returned from available fields.

    Args:
        row (dict): e.g., {"A2": "123 Main St", "B2": "Toronto", ...}
        row_number (int): The Excel row number, e.g., 2
        json_path (str): Path to the info.json mapping

    Returns:
        dict: {
            "address": "123 Main St, Toronto, M4C 1A1",
            "needs_ai": {"province": True, "country": True}
        }
    """

    # Load the JSON configuration that tells us which columns contain address parts
    # This JSON was generated by the AI interpreter to map Excel columns to address fields
    with open(json_path, "r") as f:
        info_json = json.load(f)

    # Get the main address columns from the JSON configuration
    # These are the primary address fields like street, city, postal code
    address_cols = info_json.get("if_multi_column_address", {})
    
    # Get additional address columns from the JSON configuration
    # These are secondary fields like province/state, country
    additional_cols = info_json.get("additional_address_information", {})

    # Build unified address mapping that combines both main and additional fields
    # This creates a single dictionary that maps field names to their column letters
    # Example: {"street_address": "A", "city": "B", "province": "C", "postal_code": "D", "country": "E"}
    address_fields = {
        "street_address": address_cols.get("street_address"),      
        "city": address_cols.get("city"),                         
        "province": additional_cols.get("province"),               
        "postal_code": address_cols.get("postal"),                
        "country": additional_cols.get("country")                  
    }

    # Initialize result dictionary to store the actual address values
    # This will hold the cleaned address parts like {"street_address": "123 Main St", "city": "Toronto"}
    result = {}
    
    # Initialize needs_ai dictionary to track which fields need AI processing
    # If a field is missing or invalid, we mark it for AI to fill in later
    needs_ai = {}

    # Process each address field (street, city, province, postal, country)
    for field, col_letter in address_fields.items():
        if col_letter:  # Field exists in JSON configuration
            # Create the cell reference (e.g., "A2", "B2", "C2")
            # This tells us exactly which cell in the Excel row contains this address part
            key = f"{col_letter}{row_number}"
            
            # Get the value from the row dictionary and strip whitespace
            # If the cell doesn't exist, default to empty string
            value = row.get(key, "").strip()

            # Validate the address field value
            # Address parts should be between 2 and 40 characters
            # This prevents very short or very long values that are likely errors
            if not value or len(value) < 2 or len(value) > 40:
                # Value is missing or invalid - mark for AI processing
                result[field] = " "  # Use space as placeholder
                needs_ai[field] = True  # Flag this field for AI to fill in
            else:
                # Value is valid - use it as is
                result[field] = value
        else:
            # Column doesn't exist in JSON configuration at all â€“ skip it
            # This happens when the AI interpreter didn't find a column for this field
            continue

    # Format the address string in the preferred order
    # We want addresses to be: street, city, province, postal, country
    # This creates a consistent format regardless of how the Excel columns are arranged
    ordered_fields = ["street_address", "city", "province", "postal_code", "country"]
    
    # Build the formatted parts list, only including fields that exist in our result
    # This handles cases where some address parts are missing from the Excel file
    formatted_parts = []
    for field in ordered_fields:
        if field in result and result[field] and result[field].strip() != " " and result[field].strip() != "":
            # Only include fields that exist and have valid values (not just spaces or empty)
            formatted_parts.append(result[field].strip())
    
    # Join all the address parts with commas to create the final formatted address
    # Example: "123 Main St, Toronto, ON, M4C 1A1, Canada"
    formatted_address = ", ".join(formatted_parts) if formatted_parts else ""

    # Return both the formatted address and the AI needs information
    # The calling function can use this to know which parts need AI processing
    return {
        "address": formatted_address,  
        "needs_ai": needs_ai           
    }

