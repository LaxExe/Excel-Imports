import openpyxl
import json
import re
import pycountry
from geopy.geocoders import Nominatim
from geopy.exc import GeocoderTimedOut, GeocoderUnavailable, GeocoderServiceError
import time


def is_1_column_tag(filepath):

    with open(filepath, "r") as f:
        info_json = json.load(f)

    is_1_column = info_json["required_fields"]["address_takes_up_1_column"]

    return is_1_column

def result_format(result, required_format, skip):
    if skip:
        return True
    
    formatted_parts = []

    for key in required_format:
        if key in result:
            formatted_parts.append(result[key])
        else:
            return True

    formatted_string = ", ".join(formatted_parts)
    return formatted_string

def column_1_address_skip(address, format_str, separator):
    format_parts = [f.strip() for f in format_str.split(separator)]
    address_parts = [a.strip() for a in address.split(separator)]

    required_format = [ "Postal Code", "Street", "City", "Province"]

    result = {}
    skip = False

    extra_count = len(address_parts) - len(format_parts)

    if extra_count >= 0:
        for i, key in enumerate(format_parts):
            if i == 0:
                value = separator.join(address_parts[:extra_count + 1]).strip()
            else:
                value = address_parts[i + extra_count]

            if len(value) < 2 or len(value) > 40:
                skip = True  
                break

            result[key] = value
    else:
        skip = True

    if skip:
        return skip

    result_string = result_format(result, required_format, skip)

    return result_string


def column_multi_address(row, row_number, json_path="info.json"):
    """
    Handles multi-column address rows.

    - If a column doesn't exist in JSON, it's skipped.
    - If a column exists but the value in a row is missing or invalid, the field is marked for AI.
    - A formatted address is returned from available fields.

    Args:
        row (dict): e.g., {"A2": "123 Main St", "B2": "Toronto", ...}
        row_number (int): The Excel row number, e.g., 2
        json_path (str): Path to the info.json mapping

    Returns:
        dict: {
            "address": "123 Main St, Toronto, M4C 1A1",
            "needs_ai": {"province": True, "country": True}
        }
    """

    # Load the JSON configuration that tells us which columns contain address parts
    # This JSON was generated by the AI interpreter to map Excel columns to address fields
    with open(json_path, "r") as f:
        info_json = json.load(f)

    # Get the main address columns from the JSON configuration
    # These are the primary address fields like street, city, postal code
    address_cols = info_json.get("if_multi_column_address", {})
    
    # Get additional address columns from the JSON configuration
    # These are secondary fields like province/state, country
    additional_cols = info_json.get("additional_address_information", {})

    # Build unified address mapping that combines both main and additional fields
    # This creates a single dictionary that maps field names to their column letters
    # Example: {"street_address": "A", "city": "B", "province": "C", "postal_code": "D", "country": "E"}
    address_fields = {
        "street_address": address_cols.get("street_address"),      
        "city": address_cols.get("city"),                         
        "province": additional_cols.get("province"),               
        "postal_code": address_cols.get("postal"),                
        "country": additional_cols.get("country")                  
    }

    # Initialize result dictionary to store the actual address values
    # This will hold the cleaned address parts like {"street_address": "123 Main St", "city": "Toronto"}
    result = {}
    
    # Initialize needs_ai dictionary to track which fields need AI processing
    # If a field is missing or invalid, we mark it for AI to fill in later
    needs_ai = {}

    # Process each address field (street, city, province, postal, country)
    for field, col_letter in address_fields.items():
        if col_letter:  # Field exists in JSON configuration
            # Create the cell reference (e.g., "A2", "B2", "C2")
            # This tells us exactly which cell in the Excel row contains this address part
            key = f"{col_letter}{row_number}"
            
            # Get the value from the row dictionary and strip whitespace
            # If the cell doesn't exist, default to empty string
            value = row.get(key, "").strip()

            # Validate the address field value
            # Address parts should be between 2 and 40 characters
            # This prevents very short or very long values that are likely errors
            if not value or len(value) < 2 or len(value) > 40:
                # Value is missing or invalid - mark for AI processing
                result[field] = " "  # Use space as placeholder
                needs_ai[field] = True  # Flag this field for AI to fill in
            else:
                # Value is valid - use it as is
                result[field] = value
        else:
            # Column doesn't exist in JSON configuration at all â€“ skip it
            # This happens when the AI interpreter didn't find a column for this field
            continue

    # Format the address string in the preferred order
    # We want addresses to be: street, city, province, postal, country
    # This creates a consistent format regardless of how the Excel columns are arranged
    ordered_fields = ["street_address", "city", "province", "postal_code", "country"]
    
    # Build the formatted parts list, only including fields that exist in our result
    # This handles cases where some address parts are missing from the Excel file
    formatted_parts = []
    for field in ordered_fields:
        if field in result and result[field] and result[field].strip() != " " and result[field].strip() != "":
            # Only include fields that exist and have valid values (not just spaces or empty)
            formatted_parts.append(result[field].strip())
    
    # Join all the address parts with commas to create the final formatted address
    # Example: "123 Main St, Toronto, ON, M4C 1A1, Canada"
    formatted_address = ", ".join(formatted_parts) if formatted_parts else ""

    # Try to fill missing fields using geopy before returning
    # If geopy can't fill a field, we leave it missing (don't send to AI)
    if needs_ai:
        print(f"Attempting to fill missing address fields with geopy for row {row_number}...")
        geopy_result = fill_missing_address_with_geopy(result, needs_ai, address_fields)
        
        if isinstance(geopy_result, tuple) and len(geopy_result) == 2:
            filled_parts, remaining_missing = geopy_result
            # Update the result with filled fields
            result.update(filled_parts)
            # Only send to AI if there are still missing fields after geopy
            # If geopy couldn't fill them, we leave them missing for data quality
            needs_ai = remaining_missing
        else:
            # Handle case where geopy function returns unexpected format
            print("Warning: Geopy function returned unexpected format")
    
    # Rebuild formatted address with filled fields
    formatted_parts = []
    for field in ordered_fields:
        if field in result and result[field] and result[field].strip() != " " and result[field].strip() != "":
            formatted_parts.append(result[field].strip())
    
    formatted_address = ", ".join(formatted_parts) if formatted_parts else ""
    
    # needs_ai is already updated above with remaining missing fields

    # Return both the formatted address and the AI needs information
    # The calling function can use this to know which parts need AI processing
    return {
        "address": formatted_address,  
        "needs_ai": needs_ai           
    }


def fill_missing_address_with_geopy(address_parts, missing_fields, address_fields):
    """
    Uses geopy to fill missing address fields based on available information.
    Only fills fields that have columns defined in the JSON configuration.
    
    Takes in:
        address_parts (dict): Available address parts like {"street_address": "123 Main St", "postal_code": "M5V 3A8"}
        missing_fields (dict): Fields that need to be filled like {"city": True, "country": True}
        address_fields (dict): Fields that have columns defined like {"street_address": "A", "country": "H"}
    
    Returns:
        dict: Updated address_parts with filled fields, and any remaining missing fields
    """
    # If no missing fields, return as is
    if not missing_fields:
        return address_parts, {}
    
    # Initialize geocoder for address lookup
    # This will help us find missing address parts using available information
    geolocator = Nominatim(user_agent="excel_imports_app")
    
    # Build search string from available address parts
    # We combine all the parts we have to create a searchable address
    search_parts = []
    for field, value in address_parts.items():
        if value and value.strip() and value.strip() != " ":
            search_parts.append(value.strip())
    
    # If no search parts available, can't do geocoding
    if not search_parts:
        return address_parts, missing_fields
    
    # Join parts with commas for geocoding search
    search_string = ", ".join(search_parts)
    
    try:
        # Delay - geopy rate limits
        time.sleep(1)
        
        # Geocode the address using available parts
        # This will return location info if found
        location = geolocator.geocode(search_string, timeout=10)
        
        if location:
            # Get the full address string from geopy result
            display_name = location.raw.get('display_name', '')
            
            # Parse the geocoded address to extract components dynamically
            
            # Split the display name into parts for analysis
            # This gives us individual address components to work with
            geocoded_parts = display_name.split(', ')
            
            # Initialize mapping for dynamic field detection
            # We'll build this based on what we find in the geocoded address
            detected_fields = {}
            
            # Analyze each part of the address to determine what it represents
            for part in geocoded_parts:
                part = part.strip()
                
                # Detect country using pycountry library for comprehensive international support
                # This covers all countries in the world, not just a limited list
                country_found = False
                for country in pycountry.countries:
                    if (country.name.lower() in part.lower() or 
                        country.alpha_2.lower() in part.lower() or 
                        country.alpha_3.lower() in part.lower()):
                        detected_fields['country'] = part
                        country_found = True
                        break
                
                # Detect postal codes (patterns vary by country but usually contain letters/numbers)
                if not country_found and any(char.isdigit() for char in part) and any(char.isalpha() for char in part) and len(part) >= 3:
                    # This could be a postal code - check if it matches common patterns
                    if re.match(r'^[A-Z0-9\s-]{3,10}$', part.upper()):
                        detected_fields['postal_code'] = part
                
                # Detect provinces/states (usually 2-3 letter codes or full names)
                elif not country_found and len(part) <= 3 and part.isupper():
                    # Likely a state/province code (ON, BC, CA, NY, TX, etc.)
                    detected_fields['province'] = part
                elif not country_found and len(part) > 3 and not any(char.isdigit() for char in part):
                    # Could be a city or province name (check if it's not already identified as country)
                    if 'country' not in detected_fields or part not in detected_fields['country']:
                        if 'city' not in detected_fields:
                            detected_fields['city'] = part
                        elif 'province' not in detected_fields:
                            detected_fields['province'] = part
            
            # Fill missing fields using dynamically detected components
            # Only fill fields that have columns defined in JSON config
            updated_parts = address_parts.copy()
            remaining_missing = missing_fields.copy()
            
            for field, is_missing in missing_fields.items():
                # Only try to fill fields that have columns defined
                # This prevents adding extra fields that aren't in the Excel structure
                if is_missing and field in detected_fields and field in address_fields and address_fields[field]:
                    # Use the dynamically detected value for this field
                    updated_parts[field] = detected_fields[field]
                    remaining_missing[field] = False
                # If geopy couldn't find it, leave it missing (don't send to AI)
            
            return updated_parts, remaining_missing
        else:
            # No location found 
            return address_parts, {}
            
    except (GeocoderTimedOut, GeocoderUnavailable) as e:
        # Handle geopy service errors
        print(f"Geopy error: {e}")
        return address_parts, {} 
    except Exception as e:
        # Handle any unexpected errors
        print(f"Unexpected error in geopy: {e}")
        return address_parts, {}  









 
geolocator = Nominatim(user_agent="address_locator")
 
def street_and_postal_code(street, postal_code):
 
  if not street and not postal_code:
    return "Street and postal code are missing"
 
  try:
    if street and postal_code:
      location = geolocator.geocode(f"{street} {postal_code}", exactly_one=True, timeout=10)
      return location.address if location else "Unable to extract address"
    else:
      return "No Results Found"
  except GeocoderTimedOut:
    return "No Results Found"
  except GeocoderServiceError as e:
    return "No Results Found"
  except Exception as e:
    return "No Results Found"
 
 
def street_and_city(street, city):
 
  if not street and not city:
    return "Street and city are missing"
 
  try:
    if street and city:
      location = geolocator.geocode(f"{street} {city}", exactly_one=True, timeout=10)
      return location.address if location else "Unable to extract address"
    else:
      return "No Results Found"
  except GeocoderTimedOut:
    return "No Results Foun"
  except GeocoderServiceError as e:
    return "No Results Found"
  except Exception as e:
    return "No Results Found"
 
